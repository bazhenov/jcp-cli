//! Integrations tests.
//!
//! Although Adapter uses tokio runtime to drive both transports (uplink/downlink) concurrently,
//! we intentionally use std `#[test]` here instead of `#[tokio:test]`. Adapter is designed to be tested
//! in synchronous manner without awaiting (see. [`TestHarness`] docs).
//!
//! It means that we can not do `.awaits` in tests, which is intentional. Also some adidtional
//! tokio facilities which requires Tokio runtime to be present might be unavailable (like [`tokio::time::sleep()`]).
//! If this is the case, it is possible to use `#[tokio:test]`, but additional caution needs to be taken
//! to keep tests fast and reliable.

use agent_client_protocol::{
    AGENT_METHOD_NAMES, AgentResponse, CLIENT_METHOD_NAMES, ClientRequest, ContentBlock,
    InitializeRequest, InitializeResponse, NewSessionRequest, PromptRequest, PromptResponse,
    ProtocolVersion, SessionNotification, SessionUpdate, StopReason, TextContent,
};
use harness::TestHarness;
use jcp::{Config, EndTurnMeta, GitRemoteInfo, NewSessionMeta};
use serde_json::Value;

mod harness;

const TEST_GIT_URL: &str = "https://github.com/test/repo.git";
const TEST_BRANCH: &str = "main";
const TEST_REVISION: &str = "abc123";
const TEST_TOKEN: &str = "test-token";

#[test]
fn test_adapter_forwards_initialize_request_to_server() {
    let mut harness = TestHarness::new(test_config());

    // Client sends initialize request
    let request = ClientRequest::InitializeRequest(InitializeRequest::new(1.into()));
    let request_id = harness.client_send(request);

    // Agent receives the forwarded request
    let (method, recv_id, _) = harness.agent_recv().expect_request::<InitializeRequest>();
    assert_eq!(recv_id, request_id);
    assert_eq!(method, AGENT_METHOD_NAMES.initialize);

    // Agent sends response
    let initialize_response = InitializeResponse::new(ProtocolVersion::V1);
    let response = AgentResponse::InitializeResponse(initialize_response.clone());
    harness.agent_reply(recv_id, response);

    // Client receives the response (no timeout needed)
    let (id, result) = harness
        .client_recv()
        .expect_response::<InitializeResponse>();
    let result = result.expect("Expecting successful InitializeResponse");

    assert_eq!(id, request_id);
    assert_eq!(result, initialize_response);
}

#[test]
fn test_adapter_injects_meta_into_new_session_request() {
    let config = test_config();
    let expected_meta = config.new_session_meta();
    let mut harness = TestHarness::new(config);

    // Client sends newSession request (without meta)
    let request_id = harness.client_send(ClientRequest::NewSessionRequest(NewSessionRequest::new(
        "/test",
    )));

    // Agent receives the request with injected meta
    let (method, id, received) = harness.agent_recv().expect_request::<NewSessionRequest>();
    assert_eq!(method, AGENT_METHOD_NAMES.session_new);
    assert_eq!(id, request_id);

    let meta = received
        .meta
        .map(|m| serde_json::from_value::<NewSessionMeta>(serde_json::Value::Object(m)))
        .transpose()
        .expect("meta should be valid");

    assert_eq!(meta, Some(expected_meta));
}

#[test]
fn adapter_need_to_inject_chunk_with_git_info() {
    let mut harness = TestHarness::new(test_config());

    harness.initialize();
    let session_id = harness.new_session();

    // Client sends a new prompt
    let request_id = harness.client_send(ClientRequest::PromptRequest(PromptRequest::new(
        session_id,
        vec![ContentBlock::Text(TextContent::new("Test prompt"))],
    )));

    // Agent replies with a git info in meta
    let branch_name = "main";
    let git_url = "http://github.com/user/repo";
    let meta = EndTurnMeta {
        target: GitRemoteInfo {
            branch: branch_name.into(),
            url: git_url.into(),
            revision: "".into(),
        },
    };

    harness.agent_reply(
        request_id,
        AgentResponse::PromptResponse(prompt_response_with_git_meta(meta)),
    );

    // Clients get automatically generated agent message, generated by Adapter
    let (method_name, notification) = harness
        .client_recv()
        .expect_notification::<SessionNotification>();
    assert_eq!(method_name, CLIENT_METHOD_NAMES.session_update);

    if let SessionUpdate::AgentMessageChunk(chunk) = &notification.update
        && let ContentBlock::Text(content) = &chunk.content
    {
        assert!(
            content.text.contains(git_url),
            "Message should contain '{git_url}', got: {}",
            content.text
        );
        assert!(
            content.text.contains(branch_name),
            "Message should contain '{branch_name}', got: {}",
            content.text
        );
    } else {
        panic!("Expected agent message text chunk, got: {notification:?}")
    }

    // Clients gets original prompt response
    let (_, response) = harness.client_recv().expect_response::<PromptResponse>();
    let response = response.expect("Successful response expected");
    assert_eq!(response.stop_reason, StopReason::EndTurn);
}

fn prompt_response_with_git_meta(meta: EndTurnMeta) -> PromptResponse {
    let Value::Object(json_meta) = serde_json::to_value(meta).unwrap() else {
        panic!("Unexpected json type")
    };
    PromptResponse::new(StopReason::EndTurn).meta(json_meta)
}

fn test_config() -> Config {
    Config {
        git_url: TEST_GIT_URL.into(),
        branch: TEST_BRANCH.into(),
        revision: TEST_REVISION.into(),
        ai_platform_token: TEST_TOKEN.into(),
        supports_user_git_auth_flow: false,
    }
}
